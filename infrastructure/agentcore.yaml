AWSTemplateFormatVersion: "2010-09-09"
Description: "CloudFormation template for AgentCore Resources"

Parameters:
  LambdaCodeS3Key:
    Description: The S3 object key for the lambda function code (app.zip)
    Type: String
    Default: build/app.zip

  LambdaDependenciesS3Key:
    Description: The S3 object key for the lambda dependencies layer (dependencies.zip)
    Type: String
    Default: build/dependencies.zip

  GatewayName:
    Description: Name for the AgentCore Gateway
    Type: String
    Default: "researchapp-gateway"

  MemoryName:
    Description: Name for the AgentCore Memory
    Type: String
    Default: "researchapp_memory"

  LambdaTargetS3Key:
    Description: S3 key for the database API specification
    Type: String
    Default: "build/api_spec.json"
  ResourceName:
    Type: String
    Description: Name prefix for all resources
    Default: research-agent-streamlit
    AllowedPattern: '^[a-z0-9\-]+$'

  ApplicationLoadBalancerSSLCertificate:
    Type: String
    Description: ARN of ACM certificate for HTTPS (leave blank for self-signed dev cert)
    Default: ""

  ApplicationLoadBalancerCIDRWhitelist:
    Type: String
    Description: CIDR IP range allowed to access the application
    Default: "0.0.0.0/0"
    AllowedPattern: '^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\/([0-9]|[1-2][0-9]|3[0-2]))$'

  ContainerImage:
    Type: String
    Description: Docker image URI for Streamlit (leave blank to auto-build from source)
    Default: ""

  GitHubRepository:
    Type: String
    Description: Git repository URL for the Streamlit application
    Default: "https://github.com/aws-samples/sample-best-practices-for-life-science-research-agents"

  GitHubBranch:
    Type: String
    Description: Git branch to build from
    Default: "main"

  BuildDockerfile:
    Type: String
    Description: Path to Dockerfile in the repository
    Default: "infrastructure/app/Dockerfile"

  # Existing Cognito SSM Parameters
  CognitoUserPoolIdParameter:
    Type: String
    Description: SSM Parameter name for Cognito User Pool ID
    Default: /deep-research-workshop/agentcore/userpool_id

  CognitoDomainParameter:
    Type: String
    Description: SSM Parameter name for Cognito Domain
    Default: /deep-research-workshop/agentcore/cognito_domain
    

Conditions:
  UseSelfSignedSSLCertificate:
    !Equals [!Ref ApplicationLoadBalancerSSLCertificate, ""]
  HasContainerImage: !Not [!Equals [!Ref ContainerImage, ""]]

Resources:
  #########################################################
  # AgentCore
  #########################################################

  Module1AgentCoreRuntimeRole:
    Type: AWS::IAM::Role
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W28
            reason: "Explicit role name required for AgentCore service integration"
          - id: W11
            reason: "Wildcard permissions required for AgentCore service operations and Bedrock model access"
          - id: W76
            reason: "High SPCM acceptable for AgentCore runtime role with broad service permissions"
    Properties:
      RoleName: !Sub
        - "AmazonBedrockAgentCore-${AWS::Region}-${StackIdSuffix}"
        - StackIdSuffix:
            !Select [
              4,
              !Split ["-", !Select [2, !Split ["/", !Ref "AWS::StackId"]]],
            ]
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: bedrock-agentcore.amazonaws.com
            Action: sts:AssumeRole
            Condition:
              StringEquals:
                aws:SourceAccount: !Ref AWS::AccountId
              ArnLike:
                aws:SourceArn: !Sub "arn:${AWS::Partition}:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:*"
      Policies:
        - PolicyName: StandardAgentCoreRuntimeExecutionPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Sid: ECRImageAccess
                Effect: Allow
                Action:
                  - ecr:BatchGetImage
                  - ecr:GetDownloadUrlForLayer
                Resource:
                  - !Sub "arn:${AWS::Partition}:ecr:${AWS::Region}:${AWS::AccountId}:repository/*"
              - Effect: Allow
                Action:
                  - logs:DescribeLogStreams
                  - logs:CreateLogGroup
                Resource:
                  - !Sub "arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/bedrock-agentcore/runtimes/*"
              - Effect: Allow
                Action:
                  - logs:DescribeLogGroups
                Resource:
                  - !Sub "arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:*"
              - Effect: Allow
                Action:
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - !Sub "arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/bedrock-agentcore/runtimes/*:log-stream:*"
              - Sid: ECRTokenAccess
                Effect: Allow
                Action:
                  - ecr:GetAuthorizationToken
                Resource: "*"
              - Effect: Allow
                Action:
                  - xray:PutTraceSegments
                  - xray:PutTelemetryRecords
                  - xray:GetSamplingRules
                  - xray:GetSamplingTargets
                Resource:
                  - "*"
              - Effect: Allow
                Resource: "*"
                Action: cloudwatch:PutMetricData
                Condition:
                  StringEquals:
                    cloudwatch:namespace: bedrock-agentcore
              - Sid: GetAgentAccessToken
                Effect: Allow
                Action:
                  - bedrock-agentcore:GetWorkloadAccessToken
                  - bedrock-agentcore:GetWorkloadAccessTokenForJWT
                  - bedrock-agentcore:GetWorkloadAccessTokenForUserId
                Resource:
                  - !Sub "arn:${AWS::Partition}:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:workload-identity-directory/default"
                  - !Sub "arn:${AWS::Partition}:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:workload-identity-directory/default/workload-identity/*"
              - Sid: BedrockModelInvocation
                Effect: Allow
                Action:
                  - bedrock:InvokeModel
                  - bedrock:InvokeModelWithResponseStream
                Resource:
                  - !Sub "arn:${AWS::Partition}:bedrock:*::foundation-model/*"
                  - !Sub "arn:${AWS::Partition}:bedrock:${AWS::Region}:${AWS::AccountId}:*"
              - Sid: MarketplaceOperationsFromBedrockFor3pModels
                Effect: Allow
                Action:
                  - "aws-marketplace:Subscribe"
                  - "aws-marketplace:ViewSubscriptions"
                  - "aws-marketplace:Unsubscribe"
                Resource: "*"
                Condition:
                  StringEquals:
                    aws:CalledViaLast: "bedrock.amazonaws.com"
        - PolicyName: DynamoDb
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Sid: DynamoDb
                Effect: Allow
                Action:
                  - dynamodb:CreateTable
                  - dynamodb:DescribeTable
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:Scan
                  - dynamodb:Query
                Resource:
                  - "{{resolve:ssm:/deep-research-workshop/table-arn}}"
                  - "{{resolve:ssm:/deep-research-workshop/table-arn}}/*"

  Module1AgentCoreRuntimeRoleArnParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Name: /deep-research-workshop/agentcore-runtime-role-arn
      Description: ARN for AgentCore Runtime role
      Type: String
      Value: !GetAtt Module1AgentCoreRuntimeRole.Arn

  Module2AgentCoreRuntimeRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub
        - "AmazonBedrockAgentCore-Tools-${AWS::Region}-${StackIdSuffix}"
        - StackIdSuffix:
            !Select [
              4,
              !Split ["-", !Select [2, !Split ["/", !Ref "AWS::StackId"]]],
            ]
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - bedrock-agentcore.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: BedrockAgentPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Sid: ECRImageAccess
                Effect: Allow
                Action:
                  - ecr:BatchGetImage
                  - ecr:GetDownloadUrlForLayer
                Resource:
                  - !Sub arn:${AWS::Partition}:ecr:${AWS::Region}:${AWS::AccountId}:repository/bedrock-agentcore-researchapp*
              - Effect: Allow
                Action:
                  - logs:DescribeLogStreams
                  - logs:CreateLogGroup
                Resource:
                  - !Sub arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/bedrock-agentcore/runtimes/*
              - Effect: Allow
                Action:
                  - logs:DescribeLogGroups
                Resource:
                  - !Sub arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:*
              - Effect: Allow
                Action:
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - !Sub arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/bedrock-agentcore/runtimes/*:log-stream:*
              - Sid: ECRTokenAccess
                Effect: Allow
                Action:
                  - ecr:GetAuthorizationToken
                Resource: "*"
              - Effect: Allow
                Action:
                  - xray:PutTraceSegments
                  - xray:PutTelemetryRecords
                  - xray:GetSamplingRules
                  - xray:GetSamplingTargets
                Resource: "*"
              - Effect: Allow
                Action:
                  - cloudwatch:PutMetricData
                Resource: "*"
                Condition:
                  StringEquals:
                    cloudwatch:namespace: bedrock-agentcore
              - Sid: GetAgentAccessToken
                Effect: Allow
                Action:
                  - bedrock-agentcore:GetWorkloadAccessToken
                  - bedrock-agentcore:GetWorkloadAccessTokenForJWT
                  - bedrock-agentcore:GetWorkloadAccessTokenForUserId
                Resource:
                  - !Sub arn:${AWS::Partition}:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:workload-identity-directory/default
                  - !Sub arn:${AWS::Partition}:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:workload-identity-directory/default/workload-identity/researchapp*
              - Sid: ProvisionedThroughputModelInvocation
                Effect: Allow
                Action:
                  - bedrock:InvokeModel
                  - bedrock:InvokeModelWithResponseStream
                Resource:
                  - !Sub "arn:${AWS::Partition}:bedrock:*::foundation-model/*"
                  - !Sub arn:${AWS::Partition}:bedrock:${AWS::Region}:${AWS::AccountId}:*
              - Sid: SSMGetparam
                Effect: Allow
                Action:
                  - ssm:GetParameter
                Resource:
                  - !Sub arn:${AWS::Partition}:ssm:${AWS::Region}:${AWS::AccountId}:parameter/deep-research-workshop/*
              - Sid: Identity
                Effect: Allow
                Action:
                  - bedrock-agentcore:GetResourceOauth2Token
                Resource:
                  - !Sub arn:${AWS::Partition}:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:token-vault/default/oauth2credentialprovider/researchapp*
                  - !Sub arn:${AWS::Partition}:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:workload-identity-directory/default/workload-identity/researchapp*
                  - !Sub arn:${AWS::Partition}:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:workload-identity-directory/default
                  - !Sub arn:${AWS::Partition}:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:token-vault/default
              - Sid: SecretManager
                Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                Resource:
                  - !Sub arn:${AWS::Partition}:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:bedrock-agentcore-identity!default/oauth2/researchapp*
              - Sid: AgentCoreMemory
                Effect: Allow
                Action:
                  - bedrock-agentcore:ListMemories
                  - bedrock-agentcore:ListMemoryRecords
                  - bedrock-agentcore:RetrieveMemoryRecords
                  - bedrock-agentcore:GetMemory
                  - bedrock-agentcore:GetMemoryRecord
                  - bedrock-agentcore:CreateEvent
                  - bedrock-agentcore:GetEvent
                  - bedrock-agentcore:ListEvents
                Resource:
                  - !Sub arn:${AWS::Partition}:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:memory/researchapp*
              - Sid: BedrockKnowledgeBase
                Effect: Allow
                Action:
                  - bedrock:GetKnowledgeBase
                  - bedrock:GetKnowledgeBaseDocuments
                  - bedrock:ListKnowledgeBases
                  - bedrock:RetrieveAndGenerate
                  - bedrock:Retrieve
                Resource:
                  - !Sub arn:${AWS::Partition}:bedrock:${AWS::Region}:${AWS::AccountId}:knowledge-base/*
              - Sid: CognitoIDP
                Effect: Allow
                Action:
                  - cognito-idp:ListResourceServers
                  - cognito-idp:DescribeResourceServer
                  - cognito-idp:ListIdentityProviders
                  - cognito-idp:ListUserPools
                Resource:
                  - !Sub arn:${AWS::Partition}:cognito-idp:${AWS::Region}:${AWS::AccountId}:userpool/*

  Module2AgentCoreRuntimeRoleArnParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Name: /deep-research-workshop/agentcore-runtime-tools-role-arn
      Description: ARN for AgentCore Runtime role for tools example
      Type: String
      Value: !GetAtt Module2AgentCoreRuntimeRole.Arn

  GatewayAgentCoreRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - bedrock-agentcore.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: BedrockAgentPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Sid: InvokeFunction
                Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource:
                  - !GetAtt DatabaseLambda.Arn
              - Sid: GetLambdaTargetSchema
                Effect: Allow
                Action:
                  - s3:GetObject
                Resource:
                  - !Sub "arn:${AWS::Partition}:s3:::{{resolve:ssm:/deep-research-workshop/s3-bucket-name}}/*"

  # Lambda target
  DatabaseLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      Path: /service-role/
      ManagedPolicyArns:
        - !Sub "arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
      Policies:
        - PolicyName: BedrockInvokePolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - bedrock:InvokeModel
                  - bedrock:InvokeModelWithResponseStream
                Resource:
                  - !Sub "arn:${AWS::Partition}:bedrock:*::foundation-model/*"
                  - !Sub "arn:${AWS::Partition}:bedrock:${AWS::Region}:${AWS::AccountId}:*"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              Service: lambda.amazonaws.com

  DatabaseLambdaLayer:
    Type: AWS::Lambda::LayerVersion
    Properties:
      LayerName: research-agent-dependencies
      Description: Dependencies for the Database Lambda function
      Content:
        S3Bucket: "{{resolve:ssm:/deep-research-workshop/s3-bucket-name}}"
        S3Key: !Ref LambdaDependenciesS3Key
      CompatibleRuntimes:
        - python3.12
      CompatibleArchitectures:
        - arm64

  DatabaseLambda:
    Type: AWS::Lambda::Function
    Properties:
      Description: "Lambda function for Research ResearchApp Assistant"
      Handler: lambda_function.lambda_handler
      Code:
        S3Bucket: "{{resolve:ssm:/deep-research-workshop/s3-bucket-name}}"
        S3Key: !Ref LambdaCodeS3Key
      Role: !GetAtt DatabaseLambdaRole.Arn
      Runtime: python3.12
      PackageType: Zip
      Architectures:
        - arm64
      Timeout: 300
      Layers:
        - !Ref DatabaseLambdaLayer

  AgentCoreMemory:
    Type: AWS::BedrockAgentCore::Memory
    Properties:
      Name: !Ref MemoryName
      Description: "Memory for ResearchApp Agent"
      EventExpiryDuration: 30
      MemoryStrategies:
        - SemanticMemoryStrategy:
            Name: "fact_extractor"
            Description: "Extracts and stores factual information"
            Namespaces:
              - "support/user/{actorId}/facts"
        - SummaryMemoryStrategy:
            Name: "conversation_summary"
            Description: "Captures summaries of conversations"
            Namespaces:
              - "support/user/{actorId}/{sessionId}"
        - UserPreferenceMemoryStrategy:
            Name: "user_preferences"
            Description: "Captures user preferences and settings"
            Namespaces:
              - "support/user/{actorId}/preferences"
      Tags:
        Application: "ResearchApp"

  MemoryIdParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Name: /deep-research-workshop/agentcore/memory_id
      Type: String
      Value: !Ref AgentCoreMemory
      Description: AgentCore Memory ID
      Tags:
        Application: ResearchApp

  GatewayUrlParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Name: /deep-research-workshop/agentcore/gateway_url
      Type: String
      Value: !GetAtt AgentCoreGateway.GatewayUrl
      Description: AgentCore Gateway URL
      Tags:
        Application: ResearchApp

  GatewayIdParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Name: /deep-research-workshop/agentcore/gateway_id
      Type: String
      Value: !Ref AgentCoreGateway
      Description: AgentCore Gateway URL
      Tags:
        Application: ResearchApp

  AgentCoreGateway:
    Type: AWS::BedrockAgentCore::Gateway
    Properties:
      Name: !Ref GatewayName
      Description: "Research App AgentCore Gateway"
      AuthorizerType: "CUSTOM_JWT"
      ProtocolType: "MCP"
      RoleArn: !GetAtt GatewayAgentCoreRole.Arn
      AuthorizerConfiguration:
        CustomJWTAuthorizer:
          AllowedClients:
            - "{{resolve:ssm:/deep-research-workshop/agentcore/machine_client_id}}"
          DiscoveryUrl: "{{resolve:ssm:/deep-research-workshop/agentcore/cognito_discovery_url}}"
      ProtocolConfiguration:
        Mcp:
          SearchType: "SEMANTIC"
      Tags:
        Application: "ResearchApp"

  DatabaseGatewayTarget:
    Type: AWS::BedrockAgentCore::GatewayTarget
    Properties:
      GatewayIdentifier: !Ref AgentCoreGateway
      Name: "DatabaseLambda"
      Description: "Database Lambda Target for biomedical database queries"
      TargetConfiguration:
        Mcp:
          Lambda:
            LambdaArn: !GetAtt DatabaseLambda.Arn
            ToolSchema:
              S3:
                Uri: !Sub "s3://{{resolve:ssm:/deep-research-workshop/s3-bucket-name}}/${LambdaTargetS3Key}"
      CredentialProviderConfigurations:
        - CredentialProviderType: "GATEWAY_IAM_ROLE"

  # Lambda to read SSM parameters
  GetCognitoConfig:
    Type: Custom::GetCognitoConfig
    Properties:
      ServiceToken: !GetAtt GetCognitoConfigLambda.Arn
      UserPoolIdParameter: !Ref CognitoUserPoolIdParameter
      DomainParameter: !Ref CognitoDomainParameter

  GetCognitoConfigLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${ResourceName}-get-cognito-config"
      Handler: index.handler
      Role: !GetAtt GetCognitoConfigLambdaRole.Arn
      Runtime: python3.12
      Timeout: 60
      Code:
        ZipFile: |
          import boto3
          import cfnresponse

          def handler(event, context):
              try:
                  if event['RequestType'] in ['Create', 'Update']:
                      ssm = boto3.client('ssm')
                      
                      # Get User Pool ID
                      user_pool_param = event['ResourceProperties']['UserPoolIdParameter']
                      user_pool_id = ssm.get_parameter(Name=user_pool_param)['Parameter']['Value']
                      
                      # Get Cognito Domain
                      domain_param = event['ResourceProperties']['DomainParameter']
                      cognito_domain = ssm.get_parameter(Name=domain_param)['Parameter']['Value']
                      
                      # Extract just the domain name (remove https://)
                      domain_name = cognito_domain.replace('https://', '').split('.auth.')[0]
                      
                      # Get User Pool ARN
                      cognito = boto3.client('cognito-idp')
                      user_pool = cognito.describe_user_pool(UserPoolId=user_pool_id)
                      user_pool_arn = user_pool['UserPool']['Arn']
                      
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {
                          'UserPoolId': user_pool_id,
                          'UserPoolArn': user_pool_arn,
                          'DomainName': domain_name,
                          'FullDomain': cognito_domain
                      })
                  else:
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
              except Exception as e:
                  print(f"Error: {str(e)}")
                  cfnresponse.send(event, context, cfnresponse.FAILED, {})

  GetCognitoConfigLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: SSMAccess
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - ssm:GetParameter
                  - ssm:GetParameters
                Resource:
                  - !Sub "arn:${AWS::Partition}:ssm:${AWS::Region}:${AWS::AccountId}:parameter/deep-research-workshop/*"
        - PolicyName: CognitoAccess
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - cognito-idp:DescribeUserPool
                Resource: "*"

  # VPC and Networking
  Vpc:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: "10.0.0.0/16"
      EnableDnsSupport: true
      EnableDnsHostnames: true
      Tags:
        - Key: Name
          Value: !Sub "${ResourceName}-vpc"

  PublicSubnetAz1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref Vpc
      CidrBlock: "10.0.0.0/24"
      AvailabilityZone: !Select [0, !GetAZs ""]
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: !Sub "${ResourceName}-public-subnet-az1"

  PublicSubnetAz2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref Vpc
      CidrBlock: "10.0.1.0/24"
      AvailabilityZone: !Select [1, !GetAZs ""]
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: !Sub "${ResourceName}-public-subnet-az2"

  InternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
        - Key: Name
          Value: !Sub "${ResourceName}-igw"

  AttachGateway:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref Vpc
      InternetGatewayId: !Ref InternetGateway

  RouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref Vpc
      Tags:
        - Key: Name
          Value: !Sub "${ResourceName}-route-table"

  PublicRoute:
    Type: AWS::EC2::Route
    DependsOn: AttachGateway
    Properties:
      RouteTableId: !Ref RouteTable
      DestinationCidrBlock: "0.0.0.0/0"
      GatewayId: !Ref InternetGateway

  SubnetRouteTableAssociation1:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnetAz1
      RouteTableId: !Ref RouteTable

  SubnetRouteTableAssociation2:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnetAz2
      RouteTableId: !Ref RouteTable

  # Security Groups
  AlbSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: ALB Security Group
      VpcId: !Ref Vpc
      SecurityGroupIngress:
        - Description: HTTPS from allowed CIDR
          IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: !Ref ApplicationLoadBalancerCIDRWhitelist
        - Description: HTTP redirect to HTTPS
          IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: !Ref ApplicationLoadBalancerCIDRWhitelist
      SecurityGroupEgress:
        - Description: HTTPS to Cognito
          IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: "0.0.0.0/0"
      Tags:
        - Key: Name
          Value: !Sub "${ResourceName}-alb-sg"

  AlbToEcsSecurityGroupRule:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      Description: ALB to ECS on port 8501
      GroupId: !Ref AlbSecurityGroup
      IpProtocol: tcp
      FromPort: 8501
      ToPort: 8501
      DestinationSecurityGroupId: !Ref EcsSecurityGroup

  EcsSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: ECS Security Group
      VpcId: !Ref Vpc
      SecurityGroupIngress:
        - Description: From ALB on port 8501
          IpProtocol: tcp
          FromPort: 8501
          ToPort: 8501
          SourceSecurityGroupId: !Ref AlbSecurityGroup
      SecurityGroupEgress:
        - Description: HTTPS for AWS API calls
          IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: "0.0.0.0/0"
      Tags:
        - Key: Name
          Value: !Sub "${ResourceName}-ecs-sg"

  # Application Load Balancer
  ApplicationLoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: !Sub "${ResourceName}-alb"
      Scheme: internet-facing
      Type: application
      SecurityGroups:
        - !Ref AlbSecurityGroup
      Subnets:
        - !Ref PublicSubnetAz1
        - !Ref PublicSubnetAz2
      Tags:
        - Key: Name
          Value: !Sub "${ResourceName}-alb"

  TargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: !Sub "${ResourceName}-tg"
      VpcId: !Ref Vpc
      Port: 8501
      Protocol: HTTP
      TargetType: ip
      HealthCheckEnabled: true
      HealthCheckPath: /
      HealthCheckProtocol: HTTP
      HealthCheckIntervalSeconds: 30
      HealthCheckTimeoutSeconds: 5
      HealthyThresholdCount: 2
      UnhealthyThresholdCount: 3
      Tags:
        - Key: Name
          Value: !Sub "${ResourceName}-tg"

  # Cognito User Pool Client for ALB
  CognitoUserPoolClient:
    Type: AWS::Cognito::UserPoolClient
    Properties:
      ClientName: !Sub "${ResourceName}-alb-client"
      UserPoolId: !GetAtt GetCognitoConfig.UserPoolId
      GenerateSecret: true
      AllowedOAuthFlowsUserPoolClient: true
      AllowedOAuthFlows:
        - code
      AllowedOAuthScopes:
        - openid
        - email
        - profile
      SupportedIdentityProviders:
        - COGNITO
      CallbackURLs:
        - !GetAtt CallbackURL.OutputString
      ExplicitAuthFlows:
        - ALLOW_REFRESH_TOKEN_AUTH
      RefreshTokenValidity: 30
      PreventUserExistenceErrors: ENABLED

  # Lambda for callback URL
  CallbackURL:
    Type: Custom::CallbackURL
    Properties:
      ServiceToken: !GetAtt StringFunctionsLambda.Arn
      Function: lower
      InputString: !Sub "https://${ApplicationLoadBalancer.DNSName}/oauth2/idpresponse"

  StringFunctionsLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${ResourceName}-string-functions"
      Handler: index.handler
      Role: !GetAtt StringFunctionsLambdaRole.Arn
      Runtime: python3.12
      Timeout: 60
      Code:
        ZipFile: |
          import cfnresponse

          def handler(event, context):
              try:
                  if event['RequestType'] in ['Create', 'Update']:
                      function = event['ResourceProperties']['Function']
                      if function == 'lower':
                          input_string = event['ResourceProperties']['InputString']
                          output_string = input_string.lower()
                      else:
                          raise ValueError('Unsupported function.')
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, 
                                     {'OutputString': output_string})
                  else:
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
              except Exception as e:
                  print(f"Error: {str(e)}")
                  cfnresponse.send(event, context, cfnresponse.FAILED, {})

  StringFunctionsLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole

  # Self-Signed Certificate (conditional)
  SelfSignedCertificate:
    Type: Custom::SelfSignedCertificate
    Condition: UseSelfSignedSSLCertificate
    Properties:
      ServiceToken: !GetAtt CreateCertificateLambda.Arn

  CreateCertificateLambda:
    Type: AWS::Lambda::Function
    Condition: UseSelfSignedSSLCertificate
    Properties:
      FunctionName: !Sub "${ResourceName}-create-cert"
      Handler: index.handler
      Role: !GetAtt CreateCertificateLambdaRole.Arn
      Runtime: python3.12
      Timeout: 120
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          from datetime import datetime, timedelta
          import subprocess
          import sys
          import tempfile
          from pathlib import Path

          def handler(event, context):
              try:
                  if event['RequestType'] == 'Create':
                      tmp_path = Path(tempfile.gettempdir())
                      subprocess.check_call([
                          sys.executable, "-m", "pip", "install",
                          "--target={}".format(tmp_path), "cryptography"
                      ])
                      sys.path.append(str(tmp_path))
                      
                      from cryptography.hazmat.backends import default_backend
                      from cryptography.hazmat.primitives import serialization, hashes
                      from cryptography.hazmat.primitives.asymmetric import rsa
                      from cryptography import x509
                      from cryptography.x509.oid import NameOID
                      
                      key = rsa.generate_private_key(
                          public_exponent=65537, key_size=2048,
                          backend=default_backend()
                      )
                      
                      subject = issuer = x509.Name([
                          x509.NameAttribute(NameOID.COUNTRY_NAME, "US"),
                          x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, "WA"),
                          x509.NameAttribute(NameOID.LOCALITY_NAME, "Seattle"),
                          x509.NameAttribute(NameOID.ORGANIZATION_NAME, "AWS"),
                          x509.NameAttribute(NameOID.COMMON_NAME, "localhost")
                      ])
                      
                      cert = x509.CertificateBuilder()
                      cert = cert.subject_name(subject)
                      cert = cert.issuer_name(issuer)
                      cert = cert.public_key(key.public_key())
                      cert = cert.serial_number(x509.random_serial_number())
                      cert = cert.not_valid_before(datetime.utcnow())
                      cert = cert.not_valid_after(datetime.utcnow() + timedelta(days=365))
                      cert = cert.add_extension(
                          x509.SubjectAlternativeName([x509.DNSName("localhost")]),
                          critical=False,
                      )
                      cert = cert.sign(key, hashes.SHA256(), default_backend())
                      
                      cert_pem = cert.public_bytes(serialization.Encoding.PEM)
                      key_pem = key.private_bytes(
                          encoding=serialization.Encoding.PEM,
                          format=serialization.PrivateFormat.TraditionalOpenSSL,
                          encryption_algorithm=serialization.NoEncryption()
                      )
                      
                      acm = boto3.client('acm')
                      response = acm.import_certificate(
                          Certificate=cert_pem, PrivateKey=key_pem
                      )
                      
                      cert_arn = response['CertificateArn']
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, 
                                     {'CertificateArn': cert_arn}, cert_arn)
                  
                  elif event['RequestType'] == 'Delete':
                      cert_arn = event['PhysicalResourceId']
                      if cert_arn and cert_arn.startswith('arn:'):
                          acm = boto3.client('acm')
                          try:
                              acm.delete_certificate(CertificateArn=cert_arn)
                          except Exception as e:
                              print(f"Error deleting certificate: {str(e)}")
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                  
                  else:
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
              
              except Exception as e:
                  print(f"Error: {str(e)}")
                  cfnresponse.send(event, context, cfnresponse.FAILED, {})

  CreateCertificateLambdaRole:
    Type: AWS::IAM::Role
    Condition: UseSelfSignedSSLCertificate
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: ACMAccess
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - acm:ImportCertificate
                  - acm:DeleteCertificate
                Resource: "*"

  # ALB Listeners
  HttpsListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      LoadBalancerArn: !Ref ApplicationLoadBalancer
      Port: 443
      Protocol: HTTPS
      SslPolicy: ELBSecurityPolicy-TLS13-1-2-2021-06
      Certificates:
        - CertificateArn: !If
            - UseSelfSignedSSLCertificate
            - !Ref SelfSignedCertificate
            - !Ref ApplicationLoadBalancerSSLCertificate
      DefaultActions:
        - Order: 1
          Type: authenticate-cognito
          AuthenticateCognitoConfig:
            UserPoolArn: !GetAtt GetCognitoConfig.UserPoolArn
            UserPoolClientId: !Ref CognitoUserPoolClient
            UserPoolDomain: !GetAtt GetCognitoConfig.DomainName
        - Order: 2
          Type: forward
          TargetGroupArn: !Ref TargetGroup

  HttpListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      LoadBalancerArn: !Ref ApplicationLoadBalancer
      Port: 80
      Protocol: HTTP
      DefaultActions:
        - Type: redirect
          RedirectConfig:
            Protocol: HTTPS
            Port: "443"
            StatusCode: HTTP_301

  # ECS Resources
  EcsCluster:
    Type: AWS::ECS::Cluster
    Properties:
      ClusterName: !Sub "${ResourceName}-cluster"
      ClusterSettings:
        - Name: containerInsights
          Value: enabled

  EcsTaskExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy

  EcsTaskRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: BedrockAccess
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - bedrock:InvokeModel
                  - bedrock:InvokeModelWithResponseStream
                  - bedrock-agentcore:InvokeAgentRuntime
                  - bedrock-agentcore:ListAgentRuntimes
                  - bedrock-agentcore:ListAgentRuntimeVersions
                  - bedrock-agentcore:GetAgentRuntime
                Resource: "*"
              - Effect: Allow
                Action:
                  - ssm:GetParameter
                  - ssm:GetParameters
                Resource: !Sub "arn:${AWS::Partition}:ssm:${AWS::Region}:${AWS::AccountId}:parameter/*"

  EcsTaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Properties:
      Family: !Sub "${ResourceName}-task"
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      Cpu: "1024"
      Memory: "2048"
      ExecutionRoleArn: !GetAtt EcsTaskExecutionRole.Arn
      TaskRoleArn: !GetAtt EcsTaskRole.Arn
      ContainerDefinitions:
        - Name: streamlit-app
          Image: !If
            - HasContainerImage
            - !Ref ContainerImage
            - !Sub "${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${ECRRepository}:latest"
          PortMappings:
            - ContainerPort: 8501
              Protocol: tcp
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref EcsLogGroup
              awslogs-region: !Ref AWS::Region
              awslogs-stream-prefix: ecs
          Environment:
            - Name: AWS_DEFAULT_REGION
              Value: !Ref AWS::Region
            - Name: REDIRECT_URI
              Value: !Sub "https://${ApplicationLoadBalancer.DNSName}/"

  EcsLogGroup:
    Type: AWS::Logs::LogGroup
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Properties:
      LogGroupName: !Sub "/ecs/${ResourceName}"
      RetentionInDays: 7

  EcsService:
    Type: AWS::ECS::Service
    DependsOn: HttpsListener
    Properties:
      ServiceName: !Sub "${ResourceName}-service"
      Cluster: !Ref EcsCluster
      TaskDefinition: !Ref EcsTaskDefinition
      DesiredCount: 0
      LaunchType: FARGATE
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: ENABLED
          SecurityGroups:
            - !Ref EcsSecurityGroup
          Subnets:
            - !Ref PublicSubnetAz1
            - !Ref PublicSubnetAz2
      LoadBalancers:
        - ContainerName: streamlit-app
          ContainerPort: 8501
          TargetGroupArn: !Ref TargetGroup

  # ECR Repository
  ECRRepository:
    Type: AWS::ECR::Repository
    Properties:
      RepositoryName: !Ref ResourceName
      EmptyOnDelete: true
      ImageScanningConfiguration:
        ScanOnPush: true

  # CodeBuild Project
  CodeBuildProject:
    Type: AWS::CodeBuild::Project
    Properties:
      Name: !Sub "${ResourceName}-build"
      ServiceRole: !GetAtt CodeBuildRole.Arn
      Artifacts:
        Type: NO_ARTIFACTS
      Environment:
        Type: LINUX_CONTAINER
        ComputeType: BUILD_GENERAL1_SMALL
        Image: aws/codebuild/standard:7.0
        PrivilegedMode: true
        EnvironmentVariables:
          - Name: AWS_DEFAULT_REGION
            Value: !Ref AWS::Region
          - Name: AWS_ACCOUNT_ID
            Value: !Ref AWS::AccountId
          - Name: IMAGE_REPO_NAME
            Value: !Ref ResourceName
          - Name: IMAGE_TAG
            Value: latest
          - Name: DOCKERFILE_PATH
            Value: !Ref BuildDockerfile
      Source:
        Type: GITHUB
        Location: !Ref GitHubRepository
        GitCloneDepth: 1
        BuildSpec: |
          version: 0.2
          phases:
            pre_build:
              commands:
                - echo "Starting pre_build phase"
                - echo "Logging into Amazon ECR..."
                - aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com
                - echo "ECR login complete"
            build:
              commands:
                - echo "Starting build phase"
                - echo "Dockerfile path is $DOCKERFILE_PATH"
                - DOCKERFILE_DIR=$(dirname "$DOCKERFILE_PATH")
                - DOCKERFILE_NAME=$(basename "$DOCKERFILE_PATH")
                - echo "Navigating to directory $DOCKERFILE_DIR"
                - cd "$DOCKERFILE_DIR"
                - echo "Current directory:" && pwd
                - echo "Listing files:"
                - ls -la
                - docker build -t $IMAGE_REPO_NAME:$IMAGE_TAG .
                - echo "Tagging Docker image..."
                - docker tag $IMAGE_REPO_NAME:$IMAGE_TAG $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$IMAGE_REPO_NAME:$IMAGE_TAG
                - echo "Docker image tagged"
            post_build:
              commands:
                - echo "Starting post_build phase"
                - echo "Pushing Docker image to ECR..."
                - docker push $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$IMAGE_REPO_NAME:$IMAGE_TAG
                - echo "Docker image pushed to ECR"
                - echo "Build completed on $(date)"
      SourceVersion: !Ref GitHubBranch
      LogsConfig:
        CloudWatchLogs:
          Status: ENABLED
          GroupName: !Ref CodeBuildLogGroup
      TimeoutInMinutes: 15

  CodeBuildLogGroup:
    Type: AWS::Logs::LogGroup
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Properties:
      LogGroupName: !Sub "/aws/codebuild/${ResourceName}"
      RetentionInDays: 7

  CodeBuildRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: codebuild.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: CodeBuildPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - !Sub "arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:${CodeBuildLogGroup}"
                  - !Sub "arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:${CodeBuildLogGroup}:*"
              - Effect: Allow
                Action:
                  - ecr:GetAuthorizationToken
                Resource: "*"
              - Effect: Allow
                Action:
                  - ecr:BatchCheckLayerAvailability
                  - ecr:GetDownloadUrlForLayer
                  - ecr:BatchGetImage
                  - ecr:PutImage
                  - ecr:InitiateLayerUpload
                  - ecr:UploadLayerPart
                  - ecr:CompleteLayerUpload
                Resource: !GetAtt ECRRepository.Arn

  # Lambda to trigger CodeBuild
  TriggerBuildLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${ResourceName}-trigger-build"
      Handler: index.handler
      Role: !GetAtt TriggerBuildLambdaRole.Arn
      Runtime: python3.12
      Timeout: 900
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          import time

          def handler(event, context):
              try:
                  if event['RequestType'] in ['Create', 'Update']:
                      codebuild = boto3.client('codebuild')
                      ecs = boto3.client('ecs')
                      
                      project_name = event['ResourceProperties']['ProjectName']
                      cluster_name = event['ResourceProperties'].get('ClusterName')
                      service_name = event['ResourceProperties'].get('ServiceName')
                      
                      # Start build
                      print(f"Starting build for project: {project_name}")
                      response = codebuild.start_build(projectName=project_name)
                      build_id = response['build']['id']
                      print(f"Build started: {build_id}")
                      
                      # Wait for build to complete
                      while True:
                          build_status = codebuild.batch_get_builds(ids=[build_id])['builds'][0]['buildStatus']
                          print(f"Build status: {build_status}")
                          
                          if build_status == 'SUCCEEDED':
                              print("Build completed successfully")
                              break
                          elif build_status in ['FAILED', 'STOPPED', 'TIMED_OUT']:
                              print(f"Build failed with status: {build_status}")
                              cfnresponse.send(event, context, cfnresponse.FAILED, 
                                             {"Error": f"Build failed: {build_status}"})
                              return
                          
                          time.sleep(15)
                      
                      # Update ECS service if provided
                      if cluster_name and service_name:
                          print(f"Updating ECS service: {service_name}")
                          ecs.update_service(
                              cluster=cluster_name,
                              service=service_name,
                              forceNewDeployment=True,
                              desiredCount=1
                          )
                          print("ECS service updated")
                      
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, 
                                     {"BuildId": build_id})
                  else:
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
              except Exception as e:
                  print(f"Error: {str(e)}")
                  cfnresponse.send(event, context, cfnresponse.FAILED, 
                                 {"Error": str(e)})

  TriggerBuildLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: CodeBuildAccess
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - codebuild:StartBuild
                  - codebuild:BatchGetBuilds
                Resource: !GetAtt CodeBuildProject.Arn
              - Effect: Allow
                Action:
                  - ecs:UpdateService
                Resource: !Sub "arn:${AWS::Partition}:ecs:${AWS::Region}:${AWS::AccountId}:service/${EcsCluster}/${EcsService.Name}"

  # Trigger build on stack creation
  TriggerBuild:
    Type: Custom::TriggerBuild
    DependsOn:
      - ECRRepository
    Properties:
      ServiceToken: !GetAtt TriggerBuildLambda.Arn
      ProjectName: !Ref CodeBuildProject
      ClusterName: !Ref EcsCluster
      ServiceName: !GetAtt EcsService.Name

Outputs:
  ApplicationURL:
    Description: URL to access the Streamlit application
    Value: !Sub "https://${ApplicationLoadBalancer.DNSName}"

  Module1AgentCoreRuntimeRoleArn:
    Description: ARN for AgentCore Runtime role
    Value: !GetAtt Module1AgentCoreRuntimeRole.Arn

  MemoryId:
    Description: "AgentCore Memory ID"
    Value: !Ref AgentCoreMemory
    Export:
      Name: !Sub "${AWS::StackName}-MemoryId"

  MemoryArn:
    Description: "AgentCore Memory ARN"
    Value: !GetAtt AgentCoreMemory.MemoryArn
    Export:
      Name: !Sub "${AWS::StackName}-MemoryArn"

  GatewayId:
    Description: "AgentCore Gateway ID"
    Value: !Ref AgentCoreGateway
    Export:
      Name: !Sub "${AWS::StackName}-GatewayId"

  GatewayArn:
    Description: "AgentCore Gateway ARN"
    Value: !GetAtt AgentCoreGateway.GatewayArn
    Export:
      Name: !Sub "${AWS::StackName}-GatewayArn"

  GatewayUrl:
    Description: "AgentCore Gateway URL"
    Value: !GetAtt AgentCoreGateway.GatewayUrl
    Export:
      Name: !Sub "${AWS::StackName}-GatewayUrl"
